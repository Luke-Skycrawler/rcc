%language "C++"
%defines
%locations
%define parser_class_name {rcc}
// %define api.parser.class {rcc}
%{
#include <iostream>
#include <cctype>
#include <string>
#include "AST.hpp"
#include "RccGlobal.hpp"
#include "rcc.tab.hpp"
using namespace std;
extern int yylex(yy::rcc::semantic_type *yylval, yy::rcc::location_type *yylloc, RccGlobal &global);
%}

%parse-param {RccGlobal &global}
%lex-param {RccGlobal &global}
%initial-action {
	@$.begin.filename=@$.end.filename=new std::string("stdin");
}

%union {
	Nprogram* program;
	NexternalDeclaration* external_declaration;
	NfunctionDefinition* function_definition;
	NcompoundStatement* compound_statement;
	Ndeclaration* declaration;
	std::vector<Ndeclaration*>* declaration_list;
	NdeclarationSpecifiers* declaration_specifiers;
	std::vector<NinitDeclarator*>* init_declarator_list;
	NtypeSpecifier* type_specifier;
	NinitDeclarator* init_declarator;
	Ninitializer* initializer;
	std::vector<Ninitializer*>* initializer_list;
	Ndeclarator* declarator;
	NdirectDeclarator* direct_declarator;
	std::vector<NparameterDeclaration*>* parameter_list;
	NparameterDeclaration* parameter_declaration;
	std::vector<Nidentifier*>* identifier_list;
	std::vector<Nstatement*>* statement_list;
	Nstatement* statement; 
	NexprStatement* expr_statement;
	Nexpr* expr;
	NassignExpr::ASSIGN_OP_TYPE assign_op;
	NunaryExpr::UNARY_OP unary_op;
	std::vector<Nexpr*>* argument_expr_list;
	// char char_value;
	// int int_value;
	// double double_value;
	Nconstant* constant;
	// std::string *identifier_name;
	Nidentifier* identifier;
}

%token STRING_LITERAL SIZEOF
%token PTR_OP INC_OP DEC_OP LEFT_OP RIGHT_OP LE_OP GE_OP EQ_OP NE_OP
%token AND_OP OR_OP MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN ADD_ASSIGN
%token SUB_ASSIGN LEFT_ASSIGN RIGHT_ASSIGN AND_ASSIGN
%token XOR_ASSIGN OR_ASSIGN TYPE_NAME
%token CHAR INT DOUBLE

%token<identifier> IDENTIFIER
%token<constant> CHAR_CONSTANT
%token<constant> INT_CONSTANT
%token<constant> DOUBLE_CONSTANT

%type<program> program
%type<external_declaration> external_declaration
%type<function_definition> function_definition
%type<compound_statement> compound_statement
%type<declaration> declaration;
%type<declaration_list> declaration_list;
%type<declaration_specifiers> declaration_specifiers;
%type<init_declarator_list> init_declarator_list;
%type<type_specifier> type_specifier;
%type<init_declarator> init_declarator;
%type<initializer> initializer;
%type<initializer_list> initializer_list;
%type<declarator> declarator;
%type<direct_declarator> direct_declarator;
%type<parameter_list> parameter_list;
%type<parameter_declaration> parameter_declaration;
%type<identifier_list> identifier_list;
%type<statement_list> statement_list;
%type<statement> statement;
%type<expr_statement> expr_statement;
%type<expr> expr;
%type<expr> assign_expr;
%type<assign_op> assign_op;
%type<expr> cond_expr;
%type<expr> logical_or_expr;
%type<expr> logical_and_expr;
%type<expr> inclusive_or_expr; 
%type<expr> exclusive_or_expr; 
%type<expr> and_expr; 
%type<expr> equality_expr; 
%type<expr> relational_expr; 
%type<expr> shift_expr; 
%type<expr> additive_expr;
%type<expr> multiplicative_expr;
%type<expr> cast_expr;
%type<expr> unary_expr;
%type<unary_op> unary_op;
%type<expr> postfix_expr;
%type<argument_expr_list> argument_expr_list;
%type<expr> primary_expr;

%start program
%%

program
    : external_declaration {
		std::vector<NexternalDeclaration*>* tmp = new std::vector<NexternalDeclaration*>();
		tmp->push_back($1);
		$$ = new Nprogram(*tmp);
	}
	| program external_declaration {
		$$ = $1;
		$1->push_back($2);
	}
    ;

external_declaration
	: function_definition {
		$$ = $1;
	}
	| declaration {
		$$ = $1;
	}
	;

declaration_list
	: declaration {
		std::vector<Ndeclaration*>* declaration_list = new std::vector<Ndeclaration*>;
		declaration_list->push_back($1);
		$$ = declaration_list;
	}
	| declaration_list declaration { $1->push_back($2); $$ = $1; }
	;

declaration
	: declaration_specifiers ';' {
		$$ = new Ndeclaration($1);
	}
	| declaration_specifiers init_declarator_list ';' {
		$$ = new Ndeclaration($1, *$2);
	}
	;

declaration_specifiers
    : type_specifier {
		$$ = new NdeclarationSpecifiers($1);
	}
    ; // TODO: struct declaration specifiers

init_declarator_list
    : init_declarator {
		std::vector<NinitDeclarator*>* init_declarator_list = new std::vector<NinitDeclarator*>;
		init_declarator_list->push_back($1);
		$$ = init_declarator_list;
	}
	| init_declarator_list ',' init_declarator {
		$1->push_back($3);
		$$ = $1;
	}
	;

init_declarator
	: declarator { $$ = new NinitDeclarator($1); }
	| declarator '=' initializer { $$ = new NinitDeclarator($1, $3); }
	;

declarator
    : direct_declarator { $$ = new Ndeclarator($1); }
    ;

direct_declarator
	: IDENTIFIER {
		$$ = new NdirectDeclarator(NdirectDeclarator::IDENTIFIER, $1);
	}
	| '(' declarator ')' {
		$$ = new NdirectDeclarator(NdirectDeclarator::NESTED_DECLARATOR, $2);
	}
	| direct_declarator '[' INT_CONSTANT ']' {
		$$ = new NdirectDeclarator(NdirectDeclarator::SQUARE_BRACKET_CONSTANT, $1, $3);
	}
	| direct_declarator '[' ']' {
		$$ = new NdirectDeclarator(NdirectDeclarator::SQUARE_BRACKET_EMPTY, $1);
	}
	| direct_declarator '(' parameter_list ')' {
		$$ = new NdirectDeclarator(NdirectDeclarator::PARENTHESES_PARAMETER_LIST, $1, *$3);
	}
	| direct_declarator '(' identifier_list ')' {
		$$ = new NdirectDeclarator(NdirectDeclarator::PARENTHESES_IDENTIFIER_LIST, $1, *$3);
	}
	| direct_declarator '(' ')' {
		$$ = new NdirectDeclarator(NdirectDeclarator::PARENTHESES_EMPTY, $1);
	}
	;

parameter_list
	: parameter_declaration {
		std::vector<NparameterDeclaration*>* parameter_list = new std::vector<NparameterDeclaration*>;
		parameter_list->push_back($1);
		$$ = parameter_list;
	}
	| parameter_list ',' parameter_declaration {
		$$ = $1;
		$1->push_back($3);
	}
	;

parameter_declaration
	: declaration_specifiers declarator {
		$$ = new NparameterDeclaration($1, $2);
	}
	// | declaration_specifiers abstract_declarator
	| declaration_specifiers {
		$$ = new NparameterDeclaration($1);
	}
	;

identifier_list
	: IDENTIFIER {
		std::vector<Nidentifier*>* identifier_list = new std::vector<Nidentifier*>;
		identifier_list->push_back($1);
		$$ = identifier_list;
	}
	| identifier_list ',' IDENTIFIER {
		$$ = $1;
		$$->push_back($3);
	}

initializer
	: assign_expr {
		$$ = new Ninitializer($1);
	}
	| '{' initializer_list '}' {
		$$ = new Ninitializer(*$2);
	}
	| '{' initializer_list ',' '}' {
		$$ = new Ninitializer(*$2);
	}
	;

initializer_list
	: initializer {
		std::vector<Ninitializer*>* initializer_list = new std::vector<Ninitializer*>;
		initializer_list->push_back($1);
		$$ = initializer_list;
	}
	| initializer_list ',' initializer {
		$$ = $1;
		$1->push_back($3);
	}
	;

function_definition
	: declaration_specifiers declarator declaration_list compound_statement {
		$$ = new NfunctionDefinition($1, $2, *$3, $4);
	}
	| declaration_specifiers declarator compound_statement {
		$$ = new NfunctionDefinition($1, $2, $3);
	}
	| declarator declaration_list compound_statement {
		$$ = new NfunctionDefinition($1, *$2, $3);
	}
	| declarator compound_statement {
		$$ = new NfunctionDefinition($1, $2);
	}
	;

compound_statement
	: '{' '}' { $$ = new NcompoundStatement(); }
	| '{' statement_list '}' { $$ = new NcompoundStatement(*$2); }
	| '{' declaration_list '}' { $$ = new NcompoundStatement(*$2); }
	| '{' declaration_list statement_list '}' { $$ = new NcompoundStatement(*$2, *$3); }
	;

statement_list
	: statement {
		std::vector<Nstatement*>* statement_list = new std::vector<Nstatement*>;
		statement_list->push_back($1);
		$$ = statement_list;
	}
	| statement_list statement {
		$$ = $1;
		$$->push_back($2);
	}
	;

statement
	: expr_statement {
		$$ = $1;
	}
	| compound_statement {
		$$ = $1;
	}
	;

expr_statement
    : ';' {
		$$ = new NexprStatement();
	}
    | expr ';' {
		$$ = new NexprStatement($1);
	}
    ;




type_specifier
    : CHAR {
		$$ = new NtypeSpecifier(RCC_CHAR);
	}
    | INT {
		$$ = new NtypeSpecifier(RCC_INT);
	}
    | DOUBLE {
		$$ = new NtypeSpecifier(RCC_DOUBLE);
	}
    ;




expr
    : assign_expr {
		std::vector<Nexpr*>* tmp = new std::vector<Nexpr*>;
		tmp->push_back($1);
		$$ = new Nexpr(*tmp);
	}
    | expr ',' assign_expr {
		$$ = $1;
		$$->push_back($3);
	}
    ;

assign_expr
    : cond_expr { $$ = $1; }
    | unary_expr assign_op assign_expr {
		$$ = new NassignExpr($1, $2, $3);
	}
    ;

assign_op
	: '=' {$$ = NassignExpr::EQUAL;}
	| MUL_ASSIGN {$$ = NassignExpr::MUL_ASSIGN;}
	| DIV_ASSIGN {$$ = NassignExpr::DIV_ASSIGN;}
	| MOD_ASSIGN {$$ = NassignExpr::MOD_ASSIGN;}
	| ADD_ASSIGN {$$ = NassignExpr::ADD_ASSIGN;}
	| SUB_ASSIGN {$$ = NassignExpr::SUB_ASSIGN;}
	| LEFT_ASSIGN {$$ = NassignExpr::LEFT_ASSIGN;}
	| RIGHT_ASSIGN {$$ = NassignExpr::RIGHT_ASSIGN;}
	| AND_ASSIGN {$$ = NassignExpr::AND_ASSIGN;}
	| XOR_ASSIGN {$$ = NassignExpr::XOR_ASSIGN;}
	| OR_ASSIGN {$$ = NassignExpr::OR_ASSIGN;}
	;

cond_expr
	: logical_or_expr { $$ = $1; }
	| logical_or_expr '?' expr ':' cond_expr {
		$$ = new NcondExpr($1, $3, $5);
	}
	;

logical_or_expr
	: logical_and_expr { $$ = $1; }
	| logical_or_expr OR_OP logical_and_expr {
		$$ = new NlogicalOrExpr($1, $3);
	}
	;

logical_and_expr
	: inclusive_or_expr { $$ = $1; }
	| logical_and_expr AND_OP inclusive_or_expr {
		$$ = new NlogicalAndExpr($1, $3);
	}
	;

inclusive_or_expr
    : exclusive_or_expr { $$ = $1; }
	| inclusive_or_expr '|' exclusive_or_expr {
		$$ = new NinclusiveOrExpr($1, $3);
	}
	;

exclusive_or_expr
	: and_expr { $$ = $1; }
	| exclusive_or_expr '^' and_expr {
		$$ = new NexclusiveOrExpr($1, $3);
	}
	;

and_expr
	: equality_expr { $$ = $1; }
	| and_expr '&' equality_expr {
		$$ = new NandExpr($1, $3);
	}
	;

equality_expr
	: relational_expr { $$ = $1; }
	| equality_expr EQ_OP relational_expr {
		$$ = new NequalityExpr($1, NequalityExpr::EQ_OP, $3);
	}
	| equality_expr NE_OP relational_expr {
		$$ = new NequalityExpr($1, NequalityExpr::NE_OP, $3);
	}
	;

relational_expr
	: shift_expr { $$ = $1; }
	| relational_expr '<' shift_expr {
		$$ = new NrelationalExpr($1, NrelationalExpr::L_OP, $3);
	}
	| relational_expr '>' shift_expr {
		$$ = new NrelationalExpr($1, NrelationalExpr::G_OP, $3);
	}
	| relational_expr LE_OP shift_expr {
		$$ = new NrelationalExpr($1, NrelationalExpr::LE_OP, $3);
	}
	| relational_expr GE_OP shift_expr {
		$$ = new NrelationalExpr($1, NrelationalExpr::GE_OP, $3);
	}
	;

shift_expr
	: additive_expr { $$ = $1; }
	| shift_expr LEFT_OP additive_expr {
		$$ = new NshiftExpr($1, NshiftExpr::LEFT_OP, $3);
	}
	| shift_expr RIGHT_OP additive_expr {
		$$ = new NshiftExpr($1, NshiftExpr::RIGHT_OP, $3);
	}
	;

additive_expr
    : multiplicative_expr { $$ = $1; }
	| additive_expr '+' multiplicative_expr {
		$$ = new NadditiveExpr($1, NadditiveExpr::PLUS_OP, $3);
	}
	| additive_expr '-' multiplicative_expr {
		$$ = new NadditiveExpr($1, NadditiveExpr::MINUS_OP, $3);
	}
	;

multiplicative_expr
    : cast_expr { $$ = $1; }
	| multiplicative_expr '*' cast_expr {
		$$ = new NmultiplicativeExpr($1, NmultiplicativeExpr::MULTIPLY_OP, $3);
	}
	| multiplicative_expr '/' cast_expr {
		$$ = new NmultiplicativeExpr($1, NmultiplicativeExpr::DIVIDE_OP, $3);
	}
	| multiplicative_expr '%' cast_expr {
		$$ = new NmultiplicativeExpr($1, NmultiplicativeExpr::MOD_OP, $3);
	}
	;

cast_expr
    : unary_expr { $$ = $1; }
	| '(' type_specifier ')' cast_expr {
		$$ = new NcastExpr($2, $4);
	}
	;

unary_expr
	: postfix_expr { $$ = $1; }
	| INC_OP unary_expr {
		$$ = new NunaryExpr(NunaryExpr::INC_OP, $2, nullptr);
	}
	| DEC_OP unary_expr {
		$$ = new NunaryExpr(NunaryExpr::DEC_OP, $2, nullptr);
	}
	| unary_op cast_expr {
		$$ = new NunaryExpr($1, nullptr, $2);
	}
	| SIZEOF unary_expr {
		$$ = new NunaryExpr(NunaryExpr::SIZEOF_U, $2, nullptr);
	}
	| SIZEOF '(' type_specifier ')' {
		$$ = new NunaryExpr(NunaryExpr::SIZEOF_T, $3);
	}
	;

unary_op
	: '&' { $$ = NunaryExpr::AND_OP; }
	| '*' { $$ = NunaryExpr::MULTIPLY_OP; }
	| '+' { $$ = NunaryExpr::PLUS_OP; }
	| '-' { $$ = NunaryExpr::MINUS_OP; }
	| '~' { $$ = NunaryExpr::TILDE_OP; }
	| '!' { $$ = NunaryExpr::EXCLAMATION_OP; }
	;

postfix_expr
	: primary_expr { $$ = $1; }
	| postfix_expr '[' expr ']' {
		$$ = new NpostfixExpr(NpostfixExpr::SQUARE_BRACKETS, $1, $3);
	}
	| postfix_expr '(' ')' {
		$$ = new NpostfixExpr(NpostfixExpr::PARENTHESES, $1);
	}
	| postfix_expr '(' argument_expr_list ')' {
		$$ = new NpostfixExpr(NpostfixExpr::PARENTHESES, $1, *$3);
	}
	| postfix_expr '.' IDENTIFIER {
		$$ = new NpostfixExpr(NpostfixExpr::DOT, $1, $3);
	}
	| postfix_expr PTR_OP IDENTIFIER {
		$$ = new NpostfixExpr(NpostfixExpr::PTR_OP, $1, $3);
	}
	| postfix_expr INC_OP {
		$$ = new NpostfixExpr(NpostfixExpr::INC_OP, $1);
	}
	| postfix_expr DEC_OP {
		$$ = new NpostfixExpr(NpostfixExpr::DEC_OP, $1);
	}
	;

argument_expr_list
	: assign_expr {
		std::vector<Nexpr*>* tmp = new std::vector<Nexpr*>;
		tmp->push_back($1);
		$$ = tmp;
	}
	| argument_expr_list ',' assign_expr {
		$$ = $1;
		$$->push_back($3);
	}
	;

primary_expr
	: IDENTIFIER { $$ = new NprimaryExpr($1); }
	| CHAR_CONSTANT { $$ = new NprimaryExpr($1); }
	| INT_CONSTANT { $$ = new NprimaryExpr($1); }
	| DOUBLE_CONSTANT { $$ = new NprimaryExpr($1); }
	| STRING_LITERAL {
		std::cout << "STRING_LITERAL not implemented yet!" << std::endl;
		return -1;
	}
	| '(' expr ')' { $$ = $2; }
	;

%%
using namespace std;
extern char yytext[];
extern int column;

/* void yyerror(s)
char *s;
{
	fflush(stdout);
	printf("\n%*s\n%*s\n", column, "^", column, s);
} */

int main(int argc, char **argv)
{
	RccGlobal global;
	if(argc == 2)
		global.in = argv[1];
	else if(argc != 1)
		cout << "Usage: rcc [FILE_NAME]\nor\nrcc" << endl;
	yy::rcc parser(global);
	int v = parser.parse();
	return v;
}

namespace yy
{
	void rcc::error(location const &loc, const string &s){
		cerr << "error at " << loc << ": " << s << endl;	
	}
}

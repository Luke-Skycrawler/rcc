<h1 style='text-align: center'>编译原理设计报告</h1>
<p style='text-align: center'>谢廷浩 3180101944<br/>石昊洋 3180102686</p>



[toc]

# 1. 引言

## 1.1 概述

编译原理课程大作业要求完成一个**编译器**。我们在本次课程大作业中，设计并实现了[rcc](https://github.com/Luke-Skycrawler/rcc)，一个类C语言编译器。该编译器基于FLEX进行词法分析、BISON进行语法分析、LLVM实现中间码生成及目标码生成。rcc支持的语言与C不同之处主要在于：

* 只支持char、int、double，和由它们构成的（多维）数组、结构体，以及数组、结构体间彼此的嵌套组合。**不支持指针等直接地址访问**。

* 不支持包括`jump`、`goto`、`break`、`continue`、`switch`等控制语句。

* `scanf`、`printf`会在编译时自动声明、链接，可以直接使用。注意，`scanf`的调用与C不同，无需通过`&`取变量地址，可以直接使用`scanf("%d", i)`从输入读入变量值。

* `for`循环需要使用类似Pascal的语法：

  ```pascal
  for(i: 0 to n)
  {
  	...
  }
  
  for(i: n downto 0)
  {
  	...
  }
  ```

  循环变量只在`for`语句循环体中有效。

* 不支持前缀表达式

具体的rcc语言语法可以在源代码目录下的`ebnf.txt`查看。

除了基本功能外，我们实现的**进阶主题**包括但不限于：

1. 自定义`struct`类型，可以与基本类型、结构体、基本类型或结构体的数组任意嵌套使用

2. 支持宏定义，包括

   ```C
   #define
   #define f(X)
   #ifdef
   #ifndef
   ```

3. 支持简单的错误检测、定位

## 1.2 环境

由于依赖的架构较复杂，建议在Linux、MacOS上编译运行rcc。

建议的依赖版本包括：

* flex 2.5+
* bison 3.0+
* clang 7.0+
* llvm 7.0+

已经成功测试能够编译运行rcc的版本包括：

* flex 2.6.4 + bison 3.0.4 + llvm-12 on Ubuntu 18.04 (x86_64)
* flex 2.5.35 + bison 3.7.6 + llvm-12 on MacOS (x86_64)

## 1.3 文件目录

本次实验提交的文件说明如下：

```
/ #根目录
	--rcc/ #源代码目录
		#rcc主体文件
    --Makefile #编译rcc
    --rcc.l #rcc词法分析flex文件
    --rcc.ypp #rcc语法分析bison文件
    --AST.hpp/cpp #AST树定义、声明
    --CodeGen.h/cpp #LLVM中间代码生成文件
    --RccGlobal.hpp #rcc语法、词法分析用到的全局环境
    --main.cpp #入口文件
    --macro.l #宏定义词法分析flex文件
    --macro.ypp #宏定义语法分析bison文件
    --macro.cpp #宏定义cpp文件
    --ebnf.txt #rcc语言ebnf语法规则说明
    --README.md #README说明
		--test/ #测试文件目录
			--array.c
			--assign.c
			--auto-advisor.c
			--binOp.c
			--declaration.c
			--define.c
			--easy.c
			--for_test.c
			--if_test.c
			--matrix-multiplication.c
			--matrixMul.c
			--naive_test.c
			--naive_test_ast_output.txt #可视化AST树输出
			--qsort.c
			--quicksort.c
			--recursive.c
			--ref_binOp.c
			--scanf_test.c
			--struct.c
			--struct_array.c
			--type_check.c
			--variable_access.c
			--while_test.c
	--report.pdf #该报告
    
```

## 1.4 分工

设计中，抽象语法树构成了一个天然的分工接口，AST以下的工作主要涉及代码生成，AST以上的部分涵盖了语言语法的定义。
但实际上，由于设计一棵表达能力充分又足够简洁的抽象语法树并非易事，在工作中常常有修改迭代；另外由于后端和前端的依赖关系，为了加快进度导致组员二人对词法分析、语法分析、中间码生成、测试都有着差不多的贡献，不展开说明。

# 2. 词法分析

词法分析中，编译器读入源程序字符串，解析后返回token（标记）；返回的token会在下一步被语法分析所利用。

## 2.1 Flex

rcc的词法分析使用flex完成。flex可以匹配用户指定的正则表达式，并结合bison返回token。lex文件由三部分组成：

* 定义区
* 规则区
* 用户子过程区

```
{definitions}
%%
{rules}
%%
{user subroutines}
```

Flex的具体使用、正则语言等理论知识不在此赘述。

## 2.2 具体实现



# 3. 语法分析
### 3.1 语法分析器

使用了可重入的语法分析器对象，并且设置bison以C++格式生成语法分析器代码。C++的好处在于基类指针和多态继承这两个设计模式，前者可以代替C语言的union并提供更好的抽象，后者可以为抽象语法树生成提供便利。其他的附加优势是C++的vector、string、map等标准库，极大的提高了编程效率，在不考虑编译器自举的情况下是个好选择。


# 4. 语义分析（中间码生成）
#### 4.1 llvm概述

1. 使用了LLVM提供的API，但实践中证明不能完全避免语法错误（详见3.5节）。
2. llvm 的编程模型很有趣，目标机在这里的抽象是一个拥有无限通用寄存器的计算机，基本上高级语言里的变量都能够被一个寄存器所对应，所有函数的传参也都通过这些寄存器进行，默认不保留在栈中。
3. 诸如常量折叠、运行时环境和寄存器重命名的的步骤被整合进了后续的流水线中，编程者无需费心便可享受一定的免费午餐。
#### 4.2 类型系统

#### 4.3 指针和变量
llvm里提供了功能强大的指针接口`CreateGEP()`，是数组和自定义结构的基础。

如前所述，llvm中变量都是存在寄存器里的，在变量定义时要为其分配空间。如果是数组类型，则需要先调用`CreateGEP()`分配特定大小的块。目前编译器的运行时环境基于栈，没有动态分配的堆空间。  
#### 4.4 basic block
  basic block是CFG(调用流图）里的概念，指一段单入口单出口的代码单元。在llvm里提供了这一抽象，进行循环、分支和函数主体都要创建basic block来实现。
#### 4.5 绑定
  全局作用域下共有3个查找表，分别将变量名翻译成llvm指针、将结构名翻译成


# 5. 目标代码及可执行文件生成
llvm完成了大部分得到工作。生成的中间码检查无误后，经过`pass`编译成目标平台上的二进制文件，在x86-64架构的linux和macos上生成的即为ELF文件。

经过链接器与C标准库链接得到可执行文件。链接器是通过`system("clang-7.0 output.o")`调用的。

此过程中几乎不会产生问题，故叙述较为简略。


# 6. 测试

#### 6.1 可视化
调试的有效手段之一是将AST打印。递归地对各个IR节点进行打印，调用的顺序类似中间代码生成的顺序。

#### 6.2 单元测试
发布版通过了如下的单元测试，获得了一定的软件质量保证：
```
array.c					# 
easy.c                  # 
qsort.c                 # 
struct.c                # 
assign.c                # 
for_test.c              # 
quicksort.c             # 
struct_array.c          # 
auto-advisor.c          # 
if_test.c               # 
recursive.c             # 
type_check.c            # 
binOp.c                 # 
matrixMul.c             # 
ref_binOp.c             # 
variable_access.c       # 
declaration.c           # 
matrix-multiplication.c # 
scanf_test.c            # 
while_test.c            # 
define.c                # 
naive_test.c            # 
standard.c              # 
```
#### 6.3 known errors






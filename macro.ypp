%language "C++"
%defines
%locations
%define parser_class_name {macro}
// %define api.parser.class {rcc}
/* TODO: garbage colllection */
%{
#include <cctype>
#include <string>
#include <vector>
// #include "AST.hpp"
#include "RccGlobal.hpp"
#include "macro.tab.hpp"
#define yylex(...) macrolex(__VA_ARGS__)
using namespace std;
extern int yylex(yy::macro::semantic_type *yylval, yy::macro::location_type *yylloc, RccGlobal &global);
#include "macro.hpp"
std::vector<bool> mute_restore;
%}

%parse-param {RccGlobal &global}
%lex-param {RccGlobal &global}
%initial-action {
	@$.begin.filename=@$.end.filename=(global.in=="")?new std::string("stdin"):&global.in;
}
%union {
	std::string *macro_name;
}

%token DEFINE IFDEF IFNDEF ELSE ENDIF 

%token<macro_name> IDENTIFIER OTHER
%type<macro_name> token tokens define_header
%start program
%%

program
	: block
	;
block
	: atom
	| block '\n' atom
	;

atom
	: if_block
	| define_line
	| normal_line
	;
normal_line
	: tokens 	 	{delete $1;}
	| 
	;
tokens
	: token       	{$$=$1;}
	| tokens token	{$$=new std::string(*$1+" "+*$2);delete $1;delete $2;}
	;
token
	: IDENTIFIER	{PARAM($1);LOG("identifier: %s\n",$1->data());$$=$1;REPLACE($1); }
	| ELSE			{if(!mute)fprintf(out,"else");$$=new std::string("else");}
	| OTHER			{PARAM($1);LOG("other token :%s\n",$1->data());if(!mute)fprintf(out,"%s",$1->data());$$=$1;}
	| '('			{if(!mute)fprintf(out,"(");$$=new std::string("(");}			
	| ')'			{if(!mute)fprintf(out,")");$$=new std::string(")");}   
	; 
if_block
	: if_header ENDIF		{mute=mute_restore.back();mute_restore.pop_back();}
	| if_header ELSE '\n' 	{mute=!mute;} block '\n' '#' ENDIF 	{mute=mute_restore.back();mute_restore.pop_back();}
	;
if_header
	: IF IDENTIFIER '\n' {mute_restore.push_back(mute);mute=(ifdef ^ MACRO_DEFINED($2));} block '\n' '#'
	;
IF 
	: '#' IFDEF			{ifdef=true;}
	| '#' IFNDEF		{ifdef=false;}
	;
define_header
	: '#' DEFINE IDENTIFIER						{ $$=$3;}
	;
define_line 
	: define_header {mute=true;} tokens 		{LOG("DEFINED identifier %s\n",$1->data());INSERT_MACRO($1,$3);mute=false;}
	| define_header 							{LOG("DEFINED identifier %s\n",$1->data());INSERT_MACRO($1);}
	| define_header {mute=true;} '(' IDENTIFIER ')'  	{LOG("MACRO with parameters\n");INSERT_PARAM_MACRO($1,$4);}	tokens
	;
%%
namespace yy
{
	void macro::error(location const &loc, const string &s){
		printf("\n\e[1m%s:%d:%d: \e[0m",loc.begin.filename->data(),loc.begin.line,loc.end.line);
		printf("\e[31;40m\e[1merror: \e[0m%s\n", "macro instruction not recongnized");
	}
}


